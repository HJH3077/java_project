
* 예약어 : 자바 프로그래밍을 하는데 특별한 의미가 있는 식별자(이름) / 자바를 쓰기위해 미리 만들어 놓은 것

자료형
1. 기본 자료형 : 자바 컴파일러에 의해 해석하는 자료형
2. 참조 자료형 : 클래스를 자료형으로 선언하는 경우!

 자료형의 종류
 논리형 - boolean : true or false의 표현 범위를 가진다.(0과 1이 아니다!) / 기본값은 false
 문자형 - char : 0~65535의 표현 범위를 가지고 문자를 표현하는데 쓰지만 숫자로 표현 범위를 가지는데 컴퓨터는 0,1로 저장되기 때문이다.
		* 숫자로 저장된다는 의미는 나중에 +,- 가 가능하다는 의미로도 해석이 가능해진다. 문자형의 + 가 가능한 이유
 정수형(소수점 x) - byte 
		  - short 
 		  - int : 정수형의 기본 값으로 -2,147,483,648 ~ 2,147,483,647의 범위를 가짐 
		  - long 
	
 * 우리는 기본적으로 정수형은 int와 long만 사용

 실수형(소수점 o) - float 
		  - double 


===== =========================== ===== ===========================

class Ex01{
	public static void main(String[] args){
	 // 논리형 : boolean - 값을 true 또는 false로만 저장(기본값은 false)
	 // 자료형 변수이름;
	  boolean bo1; // 변수선언 : 선언으로 이름을 붙여야 접근이 가능해짐.
	 // 변수이름 = 데이터;
	  bo1 = true;

	 // 변수호출 : 변수를 호출하면 가지고 있는 데이터를 내보낸다.
	 System.out.println(bo1);	

	  bo1 = false;
	 System.out.println(bo1);
	 // 자료형 변수이름 = 데이터;
	  boolean bo2 = true;
	 System.out.println(bo2);
	}	
}

===== =========================== ===== ===========================

class Ex02{
	public static void main(String[] args){
	 // 문자형 : char - 한 글자를 저장(반드시 한 글자만 가능), 문자를 사용하기 위해서는 ''(홑따옴표)를 사용한다.
	 // * 숫자를 사용할 수 있다.
	 // 최종적으로 저장은 숫자로 저장된다! (컴퓨터에 0,1로) 단, 호출 시 문자로 호출되긴 함 --> 숫자로 저장되는건 연산이 가능하다는 의미가됨.
		char k1; // 0 ~ 65535의 숫자로 표현되는 것이고 문자도 숫자로 변환되어 저장되어있음. 
			 // 문자는 사람을 위해 만든 것이지 컴퓨터는 숫자로 이해하기 때문에

		k1 = 'a' + 1; // 실제로는 숫자로 97임.
		System.out.println(k1);

		k1 = 65 + 32; // 대문자 A, 대문자 + 32 = 소문자가 됨.
		System.out.println(k1);
		
		//char k2 = '10'; --> 이건 오류임 1과 0인 10으로 2글자가 들어가 있으므로

		char k2 = '대';
		System.out.println(k2);

	// 문자를 표현하는 코드표 : ASCII(영어 숫자 표현) (영어,숫자만 쓸거면 아스키), 유니코드 = UTF - 8(모든 언어 표현)
	// 유니코드, 아스키코드 기반으로 한글, 한자, 특수문자 등 처리가 가능(java는 모든 언어가 저장되어있음.)
	}
}

===== =========================== ===== ===========================

class Ex03{
	public static void main(String[] args){
	// 정수형 : 소숫점이 없는 숫자 (정수형보다 무조건 실수형이 큼)
	// 정수형 크기 : byte < short < int < long , 정수형의 기본은 int 이다.
	// 주의사항 - byte, short 를 연산하면 결과는 무조건 int 이상이다. (32bit 처리를 하기 때문에)
	 
	// byte : -128 ~ 127 사이의 숫자만 사용가능
 	byte s1 = -127; 
	System.out.println(s1);

	s1 = -128;
	System.out.println(s1);

	//s1 = -129; --> 범위를 넘어서 오류남

	// short : -32768 ~ 32767 범위 안에 존재하는 정수를 저장
	//short s2 = 32760 + 100; --> 오류발생 : 오른쪽의 결과값이 저장되기 때문에 범위를 넘어감. 즉, 오른쪽이 우선순위가 높음
	
	// int 와 long은 범위가 넓으므로 외워서 쓸 필요가 없음. 
	// 앞으로 일반적인 정수는 무조건 int! , 그리고 아주 큰 정수를 쓸 때 long을 사용한다.
	// long에는 숫자 뒤에 L 또는 l을 붙인다.(생략가능) 
	int s3 = 117;

	long s4 = 117L;
	long s5 = 117l;
	long s6 = 117;   
	

	}
}

===== =========================== ===== ===========================

class Ex03{
	public static void main(String[] args){
	// 정수형 : 소숫점이 없는 숫자 (정수형보다 무조건 실수형이 큼)
	// 정수형 크기 : byte < short < int < long , 정수형의 기본은 int 이다.
	// 주의사항 - byte, short 를 연산하면 결과는 무조건 int 이상이다. (32bit 처리를 하기 때문에)
	 
	// byte : -128 ~ 127 사이의 숫자만 사용가능
 	byte s1 = -127; 
	System.out.println(s1);

	s1 = -128;
	System.out.println(s1);

	//s1 = -129; --> 범위를 넘어서 오류남

	// short : -32768 ~ 32767 범위 안에 존재하는 정수를 저장
	//short s2 = 32760 + 100; --> 오류발생 : 오른쪽의 결과값이 저장되기 때문에 범위를 넘어감. 즉, 오른쪽이 우선순위가 높음
	
	// int 와 long은 범위가 넓으므로 외워서 쓸 필요가 없음. 
	// 앞으로 일반적인 정수는 무조건 int! , 그리고 아주 큰 정수를 쓸 때 long을 사용한다.
	// long에는 숫자 뒤에 L 또는 l을 붙인다.(생략가능!) 
	int s3 = 117;

	long s4 = 117L;
	long s5 = 117l;
	long s6 = 117;   
	
	// 실수 : 소숫점이 존재하는 수 (무조건 정수보다는 크다.)
	// 실수의 크기 : char(단, int보다 작은것이지 byte보다는 큼 / short와는 크기가같음) < 정수(int < long) < float < double
	// 실수의 기본형은 double 이다. 
	//float는 숫자 뒤에 반드시 F 또는 f를 붙인다.(생략안됨!)
	//float s7 = 3.14;  --> 오류발생 : 기본형은 double인데 f를 안붙여서 float로 인식하여 자료형이 안맞음.
	float s7 = 3.14f;
	System.out.println(s7);

	double s8 = 3.14;
	System.out.println(s8);

	// 자동형변환 : 자료형이 자동으로 변경되는 것
	double s9 = 117; // doble과 int이므로 자료형 차이로 오류가 원래는 나야하지만 자동형변환에 의해 오류가 안남.	
	System.out.println(s9);
	}
}

===== =========================== ===== ===========================

형 변환

1. 프로모션 : 더 큰 자료형으로의 변환(자동), 정보의 손실이 발생하지 않음 
	* 왼쪽의 자료형이 오른쪽의 자료형보다 커야함. ex) double s7 = 117; --> double = int 의 차이

2. 디모션 : 더 작은 자료형으로 변환(명시, 강제), 정보의 손실이 발생할 가능성이 있음
	ex) int a = 3.14 --> 3으로 출력됨 0.14가 손실

형변환을 위해 문자형, 정수형, 실수형의 크기를 비교하는 것!
char(단, int보다 작은것이지 byte보다는 큼 / short와는 크기가같음) < 정수(int < long) < float < double

===== =========================== ===== ===========================

class Ex04{
	public static void main(String[] args){
	// 숫자들의 크기에 따른 저장 원리
	// (byte < short <= )  char < int < long < float < double
	//                    (문자) (정수형 숫자) (실수형 숫자)
	// 형변환 : 자동형변환(프로모션)과 강제형변환(디모션)

	// 자동형변환 : 작은 자료형이 큰 자료형에 저장될 때 자동으로 형변환이 일어남.
	// char를 int에 저장할 수 있다.
	char c1 = 'a';
	System.out.println(c1);
	
	int s1 = 'a'; // int로 자료형이 바뀌었기 때문에 a가 숫자로 바뀐 97이 나온다.
	System.out.println(s1); 

	int s2 = c1; // c1이 변수이고 데이터 'a'를 호출하므로 오류x
	System.out.println(s2);
	
	// int를 long에 저장할 수 있다.
	long s3 = 117L; 
	System.out.println(s3);
	long s4 = 117; // 이게 가능한 이유가 형변환 때문이다.

	// long이 flaot나 double에 저장할 수 있다.
	float s5 = s3;
	System.out.println(s5);	

	// 강제형변환 : 큰 자료형을 작은 자료형으로 저장할 때 오류가 발생한다. 이때 강제로 형을 변환해서 오류를 없앤다.
	// 		그러나, 데이터가 손실될 가능성이 있다.
	// 강제형변환 방법 : = 를 기준으로 무조건 왼쪽자료형에 맞춘다. --> = (왼쪽 자료형)(대상)

	byte k1 = (byte)(128); // 실행은 되지만 값이 -128이됨 = 데이터가 오류남, 129넣으면 -127이됨. 
			       // -128 ~ 127 이므로 127이 넘으면 한 바퀴 돌아서 다시 -128부터 나오게 되는 것임.
	System.out.println(k1);

	// char를 int를 넣는건 가능했으니 int를 char에 넣어보기
	char k2 = 97; // char는 0 ~ 65535까지 가능해서 들어가짐
	System.out.println(k2);

	int k3 = 97;
	char k4 = (char)(k3); // int를 char에 넣으므로 오류가 발생함. 강제형변환으로 실행했지만 97이 범위의 숫자이므로 손실은 x
	System.out.println(k4);

	// float나 double을 int로 저장
	int k5 = (int)(87.6);
	System.out.println(k5);

	// 응용문제 : 소숫점 첫째자리까지 구하자.
	int k6 = 87.64; // 곱하기 10후 int하면 876이되고 나누기 10.0(정수와 실수를 계산하면 실수가됨. 소수점을 위해 10이 아닌 10.0으로 계산.)을 하면 87.6이됨.
			// 이렇게 소숫점 자리구할 때 강제형변환 int를 사용하는 것임!
			// * 정수 정수 계산하면 정수 , 정수 실수 계산하면 실수가 됨!!!
	}
}

===== =========================== ===== ===========================

연산자 : 자료의 가공을 위해 정해진 방식에 따라 계산하고 결과를 얻기 위한 행위를 의미하는 기호들의 총칭.
(우리는 시프트연산자와 비트 연산자는 사용 x)