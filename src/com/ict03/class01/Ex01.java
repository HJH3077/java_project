package com.ict03.class01;

public class Ex01 {
	public static void main(String[] args) {
		// 클래스
		// 정의 : 객체(오브젝트, 인스턴스화)를 만들기 위한 모든 정보를 가지고 있는 것
		//		  (설계도면, 거푸집등으로 표현한다.)
		//		  파일 형태로 되어 있으면 *** 클래스를 객체로 만들어야만 사용 가능하다!!!
		
		// 클래스가 가지고 있는 것들 : 데이터(상태값, 속성, 정보), 기능(동작), 생성자
		// - 데이터(상태값, 속성) = 변수와 상수 => 멤버 필드
		// - 기능(동작, 작동) = 메소드 			=> 멤버 메소드
		// - 생성자 = 클래스를 객체로 만들 때 호출된다.
		// 			  생성자는 클래스 이름과 같다. 클래스 이름 = 저장이름
		//			  생성자 클래스이름() *** ()가 있으므로 메소드(기능)인데 클래스를 객체로 만들어 쓸 때 사용하는게 생성자
		//			  생성자의 목적은 멤버필드(데이터)의 초기화!
		
		// 클래스의 구조 : 헤더, 멤버필드, 멤버메소드, 생성자
		// 1. 헤더 : "[접근제한자][클래스종류] class 클래스이름 { " 부분  (대괄호가 있는건 생략가능)
		// 		- 접근제한자 : 외부에서 접근할 수 있는 권한을 말한다. (위의 public이 접근제한자)
		// 						   클래스, 멤버필드, 멤버메소드, 생성자 모두의 맨 앞에 붙을 수 있다. (생략가능, main의 public) 
		//		1) public : 누구나 다 접근가능(공용)	
		//		2) protected : 같은 패키지와 상속관계(부모자식관계)에서는 접근가능
		//		3) 생략(default) : 아무것도 안쓰면 생략으로 같은 패키지만 접근가능
		//		4) private : 외부에서는 무조건 접근이 불가, 아무것도 접근 못함
		//					 내부멤버(필드, 메소드)끼리만 접근가능              * ppt그림 참조!
		//		- 클래스 종류 : 일반적인 클래스들은 이 부분을 생략
		//						특정 클래스는 해당 예약어를 사용(final, abstract)
		//		- class : 클래스임을 나타내는 예약어
		//		- 클래스이름 : 클래스이름 = 저장이름 = 생성자
		//					   첫글자 대문자 나머지 소문자, 두 단어 이상일 때 단어들의 첫글자는 대문자, 띄어쓰기 불가,
		//					   특수문자 사용불가, 숫자는 중간이나 끝에 사용가능 예) JavaTest01, Button01Test
		
		// 2. 멤버필드
		// 		- 변수 : 언제든지 변할 수 있는 데이터를 저장하는 공간
		//				 첫글자 소문자, 두 단어 이상일 때 단어들의 첫글자는 대문자	
		//				 특수문자 사용불가, 숫자는 중간이나 끝에 사용가능 예) javaTest01, button01Test
		//		- 상수 : 한번 지정하면 변경할 수 없는 데이터를 저장하는 공간
		//				 모든 글자가 대문자, 단어와 단어 사이에 _(underscore)를 사용 할 수 있다.
		//				 예) JAVA_TEST_01, BUTTON_01_TEST
		
		// 3. 멤버메소드 : 동작, 기능, 작동하는 것
		//				   메소드이름 뒤에 무조건 '( )' 가 존재한다.
		//			 	   ** 해당 메소드를 호출하면 해당 메소드가 실행된다.
		//				   ** 실행이 끝난 메소드는 자기를 호출한 곳으로 되돌아간다.
		//				   main()는 JVM이 호출한다. (main()이 끝나면 JVM으로 되돌아간다.)
		//				   JVM으로 되돌아가면 프로그램은 종료된다.
		//		- 메소드 구성 : [접근제한자][메소드종류] 반환형 메소드이름([인자 = 매개변수]){실행내용;}
		//		1) 접근제한자 : 클래스 접근제한자와 동일. (public > protected > 생략 > private)
		//		2) 메소드종류 : instance 메소드와 static 메소드로 나눠진다.
		//						instance 메소드가 일반메소드로 이 부분을 생략한다.(메소드종류부분 생략)
		//						static 메소드는 반드시 static이라는 예약어를 사용해야한다.
		//	 ** 3) 반환형 : 메소드는 자기를 호출한 곳으로 되돌아간다.
		//					이 때 실행한 결과를 가지고 갈 때의 자료형을 반환형이라고 한다!
		//					결과를 가지고 가지 않을 때는 반환형에 void라고 쓴다.
		//					예) public static void main(String[] args){}
		//					= 누구나 다 접근할 수 있고, static 메소드이며, 되돌아 갈 때 무언가를 가지고 가지 않는다.
		//		4) 인자(= 매개변수) : 메소드가 동작을 할 때 필요한 정보를 위부에서 받아서 사용할 때 인자가 
		//							  필요하다. 외부에서 정보를 받을 때만 필요함.
		//			**	- 오버로딩(~Of) : 같은 클래스 안에서 메소드이름은 같고, 인자의 갯수나 인자의 자료형이 
		//								  다른 메소드를 말한다. 순서가 달라도 오버로딩임.
		//		5) getter() / setter() 
		//			- getter() : 호출하는 입장에서 메소드를 이용해서 멤버필드의 데이터를 얻어낼 수 있다.
		//			- setter() : 호출하는 입장에서 메소드를 이용해서 멤버필드의 데이터를 설정할 수 있다.
		
		// 4. 생성자 : 클래스를 객체로 만들 때 한번 호출되는 것
		//		- 목적 : 멤버필드(변수와 상수)의 초기값을 설정하는 것이 목적이다.
		//		- 형식 : 클래스이름과 생성자는 같다. ( 클래스이름() )
		//				 반환형이 없는 메소드와 같다.
		//		- 클래스를 객체로 만들어 쓰는 방법 
		//		  Scanner   sc      =    new       			Scanner(System.in);
		//		  클래스 참조변수   =  객체생성     생성자(클래스의 이름과 같음 대신 괄호가 있음, 인자가 있을 수도 있고 없을 수도 있음)
		//		  ** 생성자가 없으면 객체생성 불가
		//	 	  참조변수를 이용해서 객체가 가지고 있는 멤버필드나 멤버메소드를 사용할 수 있다.
		// 		  객체를 만들기 위해서는 생성자를 호출해야 하지만 
		// 	      반드시 해당 클래스가 가지고 있는 생성자만 호출이 가능하다.
		// 		- 모든 클래스는 반드시 생성자를 가지고 있다.(인터페이스는 제외)
		//		  생성자가 보이지 않는 클래스는 기본생성자로 객체를 생성하게 된다.
		//		  기본생성자란? 인자가 없는 생성자를 의미한다. 예) '클래스이름()'
		//		- 생성자도 오버로딩이 가능하다. 즉, 인자만 다르면 하나의 클래스 안에 여러 개의 생성자가 존재할 수 있다.
		
		//		- 만들어진 객체 안에 존재하는 멤버필드나 멤버메소드를 사용하는 방법
		// 		  참조변수.멤버필드, 참조변수.멤버메소드
		//		  예) Scanner scan = new Scanner(System.in); 일 때
		//			이 때 scan은 참조변수. scan.next(), scan.nextInt() => 메소드를 호출 
		
		// 멤버메소드와 멤버필드는 크게 두 가지 종류가 있다.
		// instance 메소드, instance 필드, static 메소드, static 필드
		// ** 클래스에는 일반적으로 static을 사용할 수 없다.(내부클래스는 예외)
		// - instance : 일반적인 메소드나 필드를 말한다.
		//				** 객체가 생성될 때 같이 생성되는 메소드나 필드를 말한다.
		//	호출방법 : 객체를 만들 때 참조변수를 사용 = 참조변수.메소드, 참조변수.필드
		// - static : static이 붙어있는 메소드나 필드를 말한다.
		//				** 객체 생성과 상관없이 미리 만들어진 메소드나 필드를 말한다.
		//	호출방법 : 클래스이름.메소드, 클래스이름.필드
	}
}
